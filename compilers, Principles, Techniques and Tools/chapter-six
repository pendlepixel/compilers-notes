中间代码生成

  在编译器的分析-综合模型中，前端对源程序进行分析并产生中间表示形式，后端在此基础上生成目标代码。理想情况下，和源语言相关的细节在前段分析中处理，而关于
目标机器的细节则在后端处理。基于一个适当定义的中间表示，可以把针对源语言i的前端和针对目标机器j的后端组合起来，构造得到源语言i在目标机器j上的一个编译器。
这种创建编译器组合的方法可以大大减少工作量：只要写出m中前端和n中后端处理程序，就可以得到m*n种编译程序。

  将给定源语言的一个程序翻译成特定的目标机器代码的过程中，一个编译器可能构造出一系列中间表示，如下图。高层的表示接近于源语言，而底层的表示接近于目标机器。
语法树是高层的表示，它刻画了源程序的自然地层次性结构，并且适用于静态类型检查这样的处理。低层的表示形式适用于机器相关的处理任务，比如寄存器分配、指令选择
等。通过选择不同的运算符，三地址代码既可以是高层的表示方式，也可以是低层的表示方式。
    
                                    源程序 -> 高层中间表示 -> ... -> 低层中间表示 -> 目标代码


6.1 语法树的变体：


6.2 三地址代码：
  因为三地址代码拆分了多运算符算术表达式以及控制流语句的嵌套结构，所以适用于目标代码的生成和优化。因为可以用名字来表示程序计算得到的中间结果，所以三地址
代码可以方便地进行重组。
  
三地址代码基于两个基本概念：地址和指令。
地址可以具有如下形式之一：
1.名字。为方便起见，我们允许源程序的名字作为三地址代码中的地址。在实现中，源程序的名字被替换成指向符号表条目的指针。关于该名字的所有信息都存放在该条目中。
2.常量。在实践中，编译器往往要处理很多不同类型的常量和变量。
3.编译器生成的临时变量。在每次需要临时变量的时候产生一个新名字是必要的，在优化编译器中更是如此。当为变量分配寄存器的时候，我们可以尽可能地合并这些临时
变量。

指令：
在编译器中，这些指令可以实现为对象，或者是带有运算符字段和运算分量字段的记录。四元式、三元式和间接三元式是三种这样的描述方式。
  四元式：一个四元式有四个四段，我们分别称为op,arg1,arg2,result.字段包含一个运算符的内部编码。举例来说，在三地址指令x = y + z.相应的四元式中，op字段
存放+,arg1中为y,arg2中为z,result中为x。
  三元式：一个三元式只有三个字段，我们分别称之为op,arg1,arg2.使用三元式时，我们将用运算x op y的位置来表示它的结果，而不是一个显示的临时名字表示。
  间接三元式：在优化编译器时，由于指令的位置常常会发生变化，而三元式，对于运算结果的引用是通过位置完成的，因此如果改变一条指令的位置，则引用该指令的所有
指令都要做出相应的修改。间接三元式解决了这个问题，间接三元式包含了一个指向三元式的指针的列表，而不是列出三元式序列本身。

静态单赋值形式（SSA）:
静态单赋值形式是另一种中间表示形式，它有利于实现某些类型的代码优化。SSA和三地址代码的区别主要体现在两个地方。首先，SSA中的所有赋值都是针对具有不同名字的
变量的，这也是“静态单赋值”这一名字的由来。SSA的第二个特别之处是它使用一种函数，这种函数的表示规则可以将一个if-else语句的两个定值合并起来（p237），根据
包含这个到达函数的赋值语句的不同控制流路径，这个函数返回不同的参数值。


6.3 类型和声明
类型的应用可以划分为类型检查和翻译。
类型检查：类型检查利用一组逻辑规则来推理一个程序在运行时刻的行为。更明确的讲，类型检查保证运算分量的类型和运算符的预期类型相匹配。
翻译：根据一个名字的类型，编译器可以确定这个名字在运行时刻需要多大的存储空间。类型信息还会在其他很多地方被用到，包括计算一个数组引用所指示的地址，插入
显式的类型转换，选择正确版本的算数运算符，等等。

一个过程调用或对象的实际存储空间是在运行时刻（当该过程被调用或该对象被创建时）进行分配的。然而，当我们在编译时刻检查局部声明时，可以进行相对地址的布局，
一个名字或某个数据结构分量的相对地址是指它相对于数据区域开始位置的偏移量。

局部变量名的存储布局：
  从变量类型我们可以知道该变量在运行时刻需要的内存数量。在编译时刻，我们可以使用这些数量为每个名字分配一个相对地址。名字的类型和相对地址信息保存在相应
的符号表条目中。对于字符串这样的变长数组，以及动态数组这样只有在运行时刻才能够确定其大小的数据，处理的方法是为指向这些数据的指针保留一个已知的固定大小
的存储区域。


6.4 表达式的翻译

