代码生成
  编译器模型的最后一个步骤是代码生成器。它以编译器前端生成的中间表示形式（IR）和相关的符号表信息作为输入，输出语义等价的目标程序。
  
对代码生成器的要求是很严格的。目标程序必须保持源程序的语义含义，还必须具有很高的质量。也就是说，它必须有效地利用目标机器上的可用资源。此外，代码生成器本
身必须能够高效运行。

要产生高效目标程序的编译器都会在代码生成之前包含一个优化步骤。优化器把一个IR映射为另一个可用于产生高效代码的IR。编译器的代码优化和代码生成步骤通常被称为
编译器的后端。它们能在生成目标程序之前对IR做多躺处理。

代码生成器有三个主要任务：指令选择、寄存器分配和指派、指令排序。
指令选择：指令选择考虑的问题是选择适当的目标机指令来实现IR语句。
寄存器分配和指派：寄存器分配和指派考虑的是把哪个值放在哪个寄存器中。
指令排序：指令排序考虑的是按照什么顺序来安排指令的执行。


8.1 代码生成器设计中的问题：
代码生成器的最重要的标准是生成正确的代码。正确性问题非常突出的原因是代码生成器会碰到很多种特殊情况。在优先考虑正确性的情况下，另一个重要的设计目标是把代
码生成器设计的易于实现、测试和维护。

8.1.1 代码生成器的输入：
  代码生成器的输入是由前端组成的源程序的中间表示形式以及符号表中的信息组成的。这些信息用来确定IR中的名字所指的数据对象的运行时刻地址。
  IR的中间表示形式的选择有很多种，包括诸如四元式、三元式、间接三元式等三地址表示方式；也包括诸如字节代码和堆栈机代码的虚拟机表示方式方式；包括诸如后缀表
示的线性表示方式；还包括诸如语法树和DAG的图形表示方式。

8.1.2 目标程序：
  构造一个能够产生高质量机器代码的代码生成器的难度会受到目标机器的指令集体系结构的极大影响。最常见的目标机体系结构是RISC(精简指令集计算机)、CISC(复杂指
令集计算机)和基于堆栈的结构。

  输出一个使用绝对地址的机器语言程序的优点是程序可以放在内存中的某个固定位置上，并立即执行。程序可以很快地进行编译和执行。
  
  输出可重定位的机器语言程序（通常称为目标模块,object module）可以使各个子程序能够被分别编译。一组可重定位的目标模块可以被一个链接加载器链接到一起并加载
运行。如果我们要生成可重定位的目标模块，我们就必须为链接和加载付出代价。但是这样做可以使我们得到更多的灵活性。

  输出一个汇编程序使代码生成过程变得稍微容易一些。我们可以生成符号指令，并使用汇编器的宏机制来帮助生成代码。这么做的代价是代码生成之后还需要增加一个汇编
步骤。

8.1.3 指令选择：
  代码生成器必须把IR程序映射成为可以在目标机上运行代码序列。完成这个映射的复杂性由如下的因素决定：
  1.IR的层次
  2.指令集体系结构本身的特性
  3.想要达到的生成代码的质量
  
  在8.9节，我们将看到指令选择可以用树模式匹配过程来建模。在这个过程中，我们把IR和机器指令表示为树结构。然后，我们尝试着用一组对应于机器指令的子树覆盖
一棵IR树。如果我们把每棵机器指令子树和一个代价值相关联，我们就可以用动态规划的方法来生成最优化的代码序列。

8.1.4 寄存器分配：
  代码生成的关键问题之一是决定哪个值放在哪个寄存器里面。寄存器是目标机上运行速度最快的计算单元，但是我们通常没有足够的寄存器来存放所有的值。没有存放在
寄存器中的值必须存放在内存中。使用寄存器运算分量的指令总是要比那些运算分量在内存中的指令短并且块。因此，有效利用寄存器非常重要。

  寄存器的使用经常被分解为两个子问题：
  1)寄存器分配：对于源程序中的每个点，我们选择一组将被存放在寄存器中的变量。
  2)寄存器指派：我们指定一个变量被存放在哪个寄存器中。
  即使对于单寄存器机器，找到一个从寄存器到变量的最优指派也是很困难的。从数学上讲，这个问题是NP完全的。

8.1.5 求值顺序：
  计算执行的顺序会影响目标代码的效率。相比其他的计算顺序而言，某些计算顺序对用于存放中间结果的寄存器的需求更少。但是在一般情况下，找到最好的顺序是一个
困难的NP完全问题。一开始，我们将按照中间代码生成器生成代码的顺序为三地址语句生成代码，从而暂时避开这个问题。在第10章，我们将研究对流水线计算机的代码排
序。这种流水线计算机可以在一个时钟周期内执行多个运算。


8.2 目标语言
  熟悉目标语言计算机及其指令集是设计一个优秀代码生成器的前提。为了给某个目标机器上的一个完整的源语言生成高质量的代码，我们需要了解该目标机的许多细节。
  
8.1.2 一个简单的目标机模型：
  我们的目标计算机是一个三地址机器的模型。它具有加载和保存操作、计算操作、跳转操作和条件跳转。这个计算机内部按照字节寻址，它具有n个通用寄存器R0,R1...
Rn-1.我们假设有如下种类的指令可用：
  (1)加载运算：指令LD dst, addr把位置addr上的值加载到位置dst。这个指令表示赋值dst = addr.
  (2)保存运算：指令ST x, r把寄存器r中的值保存到位置x。这个指令表示赋值x = r.
  (3)计算运算：形如OP dst, src1, src2，其中OP是一个诸如ADD或者SUB的运算符，而dst,src1和src2是内存位置。这些位置一定要相互不同。这个机器指令的作用是
把OP所代表的运算作用在位置src1, src2中的值上。
  (4)无条件跳转：指令BR L使得控制流转向标号为L的机器指令。（BR表示产生分支）
  (5)条件跳转：该指令的形式为Bcond r,L，其中r是一个寄存器，L是一个符号，而cond代表了对寄存器r中的值所做的某个常见测试。比如，当寄存器r中的值小于0时，
BLTZ r,L使得控制流跳转到标号L，否则，控制流传递到下一个机器指令。
  我们假设目标机具有多种寻址模式：
  (1)在指令中，一个位置可以是一个变量名x，它指向分配给x的内存位置
  (2)一个位置也可以是一个带有下标的形如a(r)的地址，其中a是一个变量，而r是一个寄存器。a(r)所表示的内存位置按照如下方式计算得到：a的左值加上寄存器r中的
值。比如，指令LD R1, a(R2)的效果是R1 = contents(a + contents(R2)),其中contents(x)表示x所代表的寄存器或者内存位置中存放的内容。
  (3)一个内存位置可以是一个以寄存器作为下标的整数。比如，LD R1, 100(R2)的效果是使得R1 = contents(100 + contents(R2)).也就是说，首先计算寄存器R2中
的值加上100得到的和，然后把这个和所指向的位置中的值加载到R1中。
  (4)还支持两种间接寻址方式：*r表示在寄存器r的内容所表示的位置上存放的内存位置。而*100(r)表示在r中的内容加上100的和所代表的位置上的内容所代表的位置。
  (5)我们还支持一个直接常数寻址模式。在一个常数前面加上一个前缀#。指令LD R1, #100把整数100加载到R1中，而ADD R1, R1, #100则把100加载到寄存器R1中去。
  
  
8.3 目标代码中的地址
  每个正在执行的程序运行的逻辑地址空间被划分成四个代码和数据区域：
 （1）一个静态确定的代码区Code。这个区存放可执行的目标代码。目标代码的大小可以在编译时刻确定。
 （2）一个静态确定的静态数据库Static。这个区存放全局变量和编译器生成的其他数据。全局变量和编译器数据的大小也可以在编译时刻确定。
 （3）一个动态管理的堆区Heap。这个区存放程序运行时刻分配和释放的数据对象。Heap的大小不能再编译时刻静态确定。
 （4）一个动态管理的栈区Stack。这个区存放过程的活动记录。活动记录会随着过程的调用和返回被创建和消除。和堆区一样，栈区的大小也不能在编译时刻确定。
 
静态分配，栈分配。
栈分配：如果在保存活动记录时使用相对地址，静态分配就可以变成栈分配。但是在栈分配方式中，只有等到运行时刻才能知道一个过程的活动记录的位置。这个位置通常
存放在一个寄存器里面，因此活动记录中的字可以通过相对于寄存器中值得偏移量来访问。我们的目标机的下标地址模式可以方便地完成这种访问。


8.4 基本块和流图
流图：一种用图来表示中间代码的方法。
这个表示方法可以按照如下方法构造：
1.把中间代码划分成基本块。每个基本块是满足下列条件的最大的连续三地址指令序列。
(1)控制流只能从基本块中的第一个指令进入该块。也就是说，没有跳转到基本块中间的转移指令。
(2)除了基本块的最后一个指令，控制流在离开基本块之前不会停机或者跳转。
2.基本块形成了流图的结点。而流图的边指明了哪些基本块可能紧随一个基本块之后运行。

8.4.3 流图
  当将一个中间代码程序划分成为基本块之后，我们用一个流图来表示它们之间的控制流。流图的结点就是这些基本块。从基本块B到基本块C之间有一条边当且仅当基本块
C的第一个指令可能紧跟在B的最后一个指令之后执行。存在这样一条边的原因有两种：
(1)有一个从B的结尾跳转到C的开头的条件或无条件跳转语句
(2)按照原来的三地址语句序列中的顺序，C紧跟在B之后，且B的结尾不存在无条件跳转语句。
我们说B是C的前驱，而C是B的一个后继。

8.4.5 循环
  很多代码转换依赖于对流图中“循环”的识别。如果下列条件成立，我们就说流图中的一个结点集合L是一个循环：
  (1)在L中有一个被称为循环入口的结点，它是唯一的其前驱可能在L之外的结点。也就是说，从整个流图的入口结点到L中的任何结点的路径都必然经过 循环入口的结点
，并且这个循环入口结点不是整个流图的入口结点本身。
  (2)L中的每个结点都有一个到达L的入口结点的非空路径，并且该路径全部在L中。


8.5 基本块的优化
  仅仅通过对各个基本块本身进行局部优化，我们就常常可以实质性地降低代码运行所需的时间。
8.5.1
  很多重要的局部优化技术首先把一个基本块转化成为一个DAG（有向无环图）
  我们按照如下的方式为一个基本块构造DAG:
  (1)基本块中出现的每个变量都有一个对应的DAG的结点表示其初始值
  (2)基本块中的每个语句s都有一个相关的结点N。N的子结点是基本块中的其他语句的对应结点。这些语句是在s之前、最后一个对s所使用的某个运算分量进行定值的语句。
  (3)结点N的标号是s中的运算符；同时还有一组变量被关联到N，表示s是在此基本块内最晚对这些变量进行定值的语句。
  (4)某些结点被指明为输出结点。这些结点的变量在基本块的出口处活跃。也就是说，这些变量的值可能以后会在流图的另一个基本块中被使用到。计算得到这些“活跃变
量”是全局数据流分析的问题。

基本块的DAG表示可以使我们对基本块所代表的代码进行一些转换，以改进代码的质量。
(1)我们可以消除局部公共子表达式。所谓公共子表达式就是重复计算一个已经计算得到的值得指令。
(2)我们可以消除死代码，即计算得到的值不会被使用的指令。
(3)我们可以对相互独立的语句进行重新排序，这样的重新排序可以降低一个临时值需要保持在寄存器中的时间。
(4)我们可以使用代数规则来重新排列三地址指令的运算分量的顺序，这么做有时可以简化计算过程。
  
  
8.6 一个简单地代码生成器
  本节中，将考虑一个为单个基本块生成代码的算法。它依次考虑各个三地址指令，并跟踪记录哪个值存放在哪个寄存器中。
  在代码生成中的主要问题之一是决定如何最大限度地利用寄存器。寄存器有如下四种主要使用方法：
  1.在大部分机器的体系结构中，执行一个运算时该运算的部分或者全部分量必须存放在寄存器中。
  2.寄存器很适合做临时变量，即在计算一个大表达式时存放其子表达式的值。或者更一般地讲，寄存器适合用于存放只在单个基本块内使用的变量的值。
  3.寄存器用来存放在一个基本块中计算而在另一个基本块中使用的（全局）值。比如，循环下标的值，每次循环都对该值做增量运算，并在循环体中多次被使用。
  4.寄存器经常用来帮助进行运行时刻的存储管理。比如，管理运行时刻栈包括栈指针的维护，栈顶元素也可能被存放在寄存器中。
  
8.6.1 寄存器和地址描述符
  我们需要一个数据结构来说明哪些程序变量的值当前被存放在哪个或者哪些寄存器里面。我们还需要知道当前存放在一个给定变量的内存位置的值是否就是这个变量的正
确值。因为变量的新值可能已经在寄存器中计算出来但还没有存放到内存上。这个数据结构具有下列描述符：
1.每个可用的寄存器都有一个寄存器描述符。它用来跟踪有哪些变量的当前值存放在此寄存器内。
2.每个程序变量都有一个地址描述符。它用来跟踪记录在哪个或哪些位置上是可以找到该变量的当前值。




  
  
  
  
  



