代码生成
  编译器模型的最后一个步骤是代码生成器。它以编译器前端生成的中间表示形式（IR）和相关的符号表信息作为输入，输出语义等价的目标程序。
  
对代码生成器的要求是很严格的。目标程序必须保持源程序的语义含义，还必须具有很高的质量。也就是说，它必须有效地利用目标机器上的可用资源。此外，代码生成器本
身必须能够高效运行。

要产生高效目标程序的编译器都会在代码生成之前包含一个优化步骤。优化器把一个IR映射为另一个可用于产生高效代码的IR。编译器的代码优化和代码生成步骤通常被称为
编译器的后端。它们能在生成目标程序之前对IR做多躺处理。

代码生成器有三个主要任务：指令选择、寄存器分配和指派、指令排序。
指令选择：指令选择考虑的问题是选择适当的目标机指令来实现IR语句。
寄存器分配和指派：寄存器分配和指派考虑的是把哪个值放在哪个寄存器中。
指令排序：指令排序考虑的是按照什么顺序来安排指令的执行。


8.1 代码生成器设计中的问题：
代码生成器的最重要的标准是生成正确的代码。正确性问题非常突出的原因是代码生成器会碰到很多种特殊情况。在优先考虑正确性的情况下，另一个重要的设计目标是把代
码生成器设计的易于实现、测试和维护。

8.1.1 代码生成器的输入：
  代码生成器的输入是由前端组成的源程序的中间表示形式以及符号表中的信息组成的。这些信息用来确定IR中的名字所指的数据对象的运行时刻地址。
  IR的中间表示形式的选择有很多种，包括诸如四元式、三元式、间接三元式等三地址表示方式；也包括诸如字节代码和堆栈机代码的虚拟机表示方式方式；包括诸如后缀表
示的线性表示方式；还包括诸如语法树和DAG的图形表示方式。

8.1.2 目标程序：
  构造一个能够产生高质量机器代码的代码生成器的难度会受到目标机器的指令集体系结构的极大影响。最常见的目标机体系结构是RISC(精简指令集计算机)、CISC(复杂指
令集计算机)和基于堆栈的结构。

  输出一个使用绝对地址的机器语言程序的优点是程序可以放在内存中的某个固定位置上，并立即执行。程序可以很快地进行编译和执行。
  
  输出可重定位的机器语言程序（通常称为目标模块,object module）可以使各个子程序能够被分别编译。一组可重定位的目标模块可以被一个链接加载器链接到一起并加载
运行。如果我们要生成可重定位的目标模块，我们就必须为链接和加载付出代价。但是这样做可以使我们得到更多的灵活性。

  输出一个汇编程序使代码生成过程变得稍微容易一些。我们可以生成符号指令，并使用汇编器的宏机制来帮助生成代码。这么做的代价是代码生成之后还需要增加一个汇编
步骤。

8.1.3 指令选择：
  代码生成器必须把IR程序映射成为可以在目标机上运行代码序列。完成这个映射的复杂性由如下的因素决定：
  1.IR的层次
  2.指令集体系结构本身的特性
  3.想要达到的生成代码的质量
  
  在8.9节，我们将看到指令选择可以用树模式匹配过程来建模。在这个过程中，我们把IR和机器指令表示为树结构。然后，我们尝试着用一组对应于机器指令的子树覆盖
一棵IR树。如果我们把每棵机器指令子树和一个代价值相关联，我们就可以用动态规划的方法来生成最优化的代码序列。

8.1.4 寄存器分配：
  代码生成的关键问题之一是决定哪个值放在哪个寄存器里面。寄存器是目标机上运行速度最快的计算单元，但是我们通常没有足够的寄存器来存放所有的值。没有存放在
寄存器中的值必须存放在内存中。使用寄存器运算分量的指令总是要比那些运算分量在内存中的指令短并且块。因此，有效利用寄存器非常重要。

  寄存器的使用经常被分解为两个子问题：
  1)寄存器分配：对于源程序中的每个点，我们选择一组将被存放在寄存器中的变量。
  2)寄存器指派：我们指定一个变量被存放在哪个寄存器中。
  即使对于单寄存器机器，找到一个从寄存器到变量的最优指派也是很困难的。从数学上讲，这个问题是NP完全的。

8.1.5 求值顺序：
  计算执行的顺序会影响目标代码的效率。相比其他的计算顺序而言，某些计算顺序对用于存放中间结果的寄存器的需求更少。但是在一般情况下，找到最好的顺序是一个
困难的NP完全问题。一开始，我们将按照中间代码生成器生成代码的顺序为三地址语句生成代码，从而暂时避开这个问题。在第10章，我们将研究对流水线计算机的代码排
序。这种流水线计算机可以在一个时钟周期内执行多个运算。


8.2 目标语言
  熟悉目标语言计算机及其指令集是设计一个优秀代码生成器的前提。为了给某个目标机器上的一个完整的源语言生成高质量的代码，我们需要了解该目标机的许多细节。
  
8.1.2 一个简单的目标机模型：
  我们的目标计算机是一个三地址机器的模型。它具有加载和保存操作、计算操作、跳转操作和条件跳转。这个计算机内部按照字节寻址，它具有n个通用寄存器R0,R1...
Rn-1.我们假设有如下种类的指令可用：
  (1)加载运算：指令LD dst, addr把位置addr上的值加载到位置dst。这个指令表示赋值dst = addr.
  (2)保存运算：指令ST x, r把寄存器r中的值保存到位置x。这个指令表示赋值x = r.
  (3)计算运算：形如OP dst, src1, src2，其中OP是一个诸如ADD或者SUB的运算符，而dst,src1和src2是内存位置。这些位置一定要相互不同。这个机器指令的作用是
把OP所代表的运算作用在位置src1, src2中的值上。
  (4)无条件跳转：指令BR L使得控制流转向标号为L的机器指令。（BR表示产生分支）
  (5)条件跳转：该指令的形式为Bcond r,L，其中r是一个寄存器，L是一个符号，而cond代表了对寄存器r中的值所做的某个常见测试。比如，当寄存器r中的值小于0时，
BLTZ r,L使得控制流跳转到标号L，否则，控制流传递到下一个机器指令。
  我们假设目标机具有多种寻址模式：
  (1)在指令中，一个位置可以是一个变量名x，它指向分配给x的内存位置
  (2)一个位置也可以是一个带有下标的形如a(r)的地址，其中a是一个变量，而r是一个寄存器。a(r)所表示的内存位置按照如下方式计算得到：a的左值加上寄存器r中的
值。比如，指令LD R1, a(R2)的效果是R1 = contents(a + contents(R2)),其中contents(x)表示x所代表的寄存器或者内存位置中存放的内容。
  (3)一个内存位置可以是一个以寄存器作为下标的整数。比如，LD R1, 100(R2)的效果是使得R1 = contents(100 + contents(R2)).也就是说，首先计算寄存器R2中
的值加上100得到的和，然后把这个和所指向的位置中的值加载到R1中。
  (4)还支持两种间接寻址方式：*r表示在寄存器r的内容所表示的位置上存放的内存位置。而*100(r)表示在r中的内容加上100的和所代表的位置上的内容所代表的位置。
  (5)我们还支持一个直接常数寻址模式。在一个常数前面加上一个前缀#。指令LD R1, #100把整数100加载到R1中，而ADD R1, R1, #100则把100加载到寄存器R1中去。
  
  
8.3 目标代码中的地址
  每个正在执行的程序运行的逻辑地址空间被划分成四个代码和数据区域：
 （1）一个静态确定的代码区Code。这个区存放可执行的目标代码。目标代码的大小可以在编译时刻确定。
 （2）一个静态确定的静态数据库Static。这个区存放全局变量和编译器生成的其他数据。全局变量和编译器数据的大小也可以在编译时刻确定。
 （3）一个动态管理的堆区Heap。这个区存放程序运行时刻分配和释放的数据对象。Heap的大小不能再编译时刻静态确定。
 （4）一个动态管理的栈区Stack。这个区存放过程的活动记录。活动记录会随着过程的调用和返回被创建和消除。和堆区一样，栈区的大小也不能在编译时刻确定。
 
  
