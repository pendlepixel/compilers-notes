2.1 引言
  编译器的工作可以分为两个阶段，分析阶段和合成阶段。编译器在分析阶段将一个源程序划分成各个组成部分，并生成源程序的内部表示形式。这种内部表示形式称为
中间代码。编译器在合成阶段将这个中间代码翻译成目标程序。

语法：描述一个语言的程序的正确形式。
语义：定义程序的含义，即每个程序在运行时做什么事情。

词法分析器使得翻译器可以处理由多个字符组成的构造，比如标识符。标识符由多个字符组成，但在语法分析阶段被当作一个单元进行处理。这样的单元就叫做词法单元。
两种中间代码的形式：
（1）抽象语法树（语法树）：表示了源程序的层次化语法结构。
（2）“三地址”指令序列。


2.2 语法定义
一种用于描述程序设计语言语法的表示方法——“上下文无关文法”。文法自然而然地描述了大多数程序设计语言构造的层次化语法结构。

比如java中的if-else语句,可以表示成这种形式：stmt -> if (expr) stmt else stmt. 其中，expr表示表达式，stmt表示语句。
其中的箭头可以读作“可以具有如下形式”。这样的规则成为产生式。在一个产生式中，像关键字if和括号这样的词法元素成为“终结符号”。像expr和stmt这样的变量
表示终结符号的序列，它们称为“非终结符号”。

一个上下文无关文法由四个元素组成：
（1）一个终结符号集合，他们有时也被称为“词法单元”。终结符号是该文法所定义的语言的基本符号的集合。
（2）一个非终结符号集合，他们有时也称为“语法变量”。每个非终结符号表示一个终结符号串的集合。
（3）一个产生式集合，每个产生式包括一个被称为产生式头或者左部的非终结符号，一个箭头，和一个产生式体或右部的由终结符号及非终结符号组成的序列。产生式主要
用来表示某个构造的某种书写形式。如果产生式头非终结符号代表一个构造，那么该产生式体就代表了该构造的一种书写方式。
（4）指定一个非终结符号为开始符号。

词法单元和终结符号：
  在编译器中，词法分析器读入源程序中的字符序列，将它们组织为具有词法含义的词素，生成并输出代表这些词素的词法单元序列。词法单元由两个部分组成：名字和属性。
词法单元的名字是语法分析器进行语法分析时候使用的抽象符号。我们常常把这些词法单元名字称为终结符号，因为他们在描述程序设计语言的文法中是以终结符号的形式
出现的。如果词法单元具有属性值，那么这个值就是一个指向符号表的指针，符号表中包含了该词法单元的附加信息。这些附加信息不是文法的组成部分，因此我们讨论文法
的时候，通常将词法单元和终结符号当做同义词。

如果某个非终结符号是某个产生式的头部，我们就说该产生式是该非终结符号的产生式。

语法分析的任务是：接受一个终结符号串作为输入，找出从文法的开始符号推导出这个串的方法。如果不能从文法的开始符号推导得到该终结符号串，则报告该终结符号串
中包含的语法错误。

一个文法的语言的另一个定义是指任何能够由某棵语法分析树生成的符号串的集合。为一个给定的终结符号串构建一棵语法分析树的过程称为对该符号串进行语法分析。

二义性：
一个文法可能又多棵语法分析树能够同时生成同一个给定的终结符号串。这样的文法称为具有二义性。
要证明一个文法具有二义性，只需要找到一个终结符号串，说明它是两棵以上语法分析树的结果。
因为具有两棵以上语法分析树的符号串通常具有多个含义，所以我们需要为编译应用设计出没有二义性的文法，或者在使用二义性文法时使用附加的规则来消除二义性。


2.3 语法制导翻译：
  语法制导翻译是通过向一个文法的产生式附加一些规则或者程序片段而得到的。比如，考虑由以下产生式生成的表达式expr: expr -> expr1 + term. 这里，expr
是两个子表达式expr1和term的和。我们可以利用expr的结构，用如下的伪代码来翻译expr：
  翻译expr1;
  翻译term;
  处理+;
  
两个与语法制导翻译相关的概念：
（1）属性：属性表示与某个程序构造相关的任意的量。属性可以是多种多样的，比如表达式的数据类型、生成的代码中的指令数目或为某个构造生成的代码中第一条指令
的位置等都是属性的例子。因为我们用文法符号（终结符号或者非终结符号）来表示程序构造，所以我们将属性的概念从程序构造扩展到表示这些构造的文法符号上。
（2）翻译方案：翻译方案是一种将程序片段附加到一个文法的各个产生式上的表示法。当在语法分析过程中使用一个产生式时，相应的程序片段就会执行。这些程序片段
的执行效果按照语法分析过程的顺序组合起来，得到的结果就是这次分析/综合过程处理源程序得到的翻译结果。

一个表达式的后缀表示可以按照下面的方式进行归纳定义：
（1）如果E是一个变量或者常量，则E的后缀表示是E本身；
（2）如果E是一个形如E1 op E2的表达式，其中op是一个二目运算符，那么E的后缀表示是E1'E2'op，这里的E1'和E2'分别是E1和E2的后缀表示；
（3）如果E是一个形如(E1)的被括号括起来的表达式，则E的后缀表示就是E1的后缀表示。


2.4 语法分析
  语法分析是决定如何使用一个文法生成一个终结符号串的过程。在讨论这个问题时，可以想象正在构建一个语法分析树，这样可以帮助我们理解分析的过程。尽管在实践
中编译器并没有真的构造出这棵树。然而，原则上语法分析器必须能够构造出语法分析树，否则将无法保证翻译的正确性。

  对于任何上下文无关文法，我们都可以构造出一个时间复杂度为O(n^3)的语法分析器。它最多使用O(n^3)的时间就可以完成一个长度为n的符号串的语法分析。但是，
三次方的时间代价太昂贵了。幸运的是，对于实际的程序设计语言而言，我们通常能够设计出一个可以被高效分析的文法。线性时间复杂度的算法足以分析实践中出现的
各种程序设计语言。程序设计语言的语法分析器几乎总是一次性地从左向右扫描输入，每次向前看一个终结符号，并在扫描时构造出分析树的各个部分。
  
  大多数语法分析方法都可以归入一下两类：自顶向下方法和自底向上方法。这两个术语指的是语法分析树节点的构造顺序。在自顶向下语法分析器中，构造过程从根节点
开始，逐步向叶子结点方向进行；而在自底向上语法分析器中，构造过程从叶子结点开始，逐步构造出根节点。自顶向下语法分析器之所以受欢迎，是因为使用这种方法
可以较容易地手工构造出高效的语法分析器。不过自底向上分析方法可以处理更多种文法和翻译方案，所以直接从文法生成语法分析器的软件工具常常使用自底向上的方法。

预测分析法：
  递归下降分析文法是一种自顶向下的语法分析方法，它使用一组递归过程来处理输入。文法的每个非终结符都有一个相关联的过程。我们考虑递归下降分析法的一个简
单形式，称为预测分析法。在预测分析法中，各个非终结符号对应的过程中的控制流可以由向前看符号无二义性地确定。在分析输入串时出现的过程调用序列隐式地定义
了该输入串的一棵语法分析树。如果需要，还可以通过这些过程调用来构建一个显式的语法分析树。
  预测分析需要知道哪些符号可能成为一个产生式体所生成串的第一个符号。更精确的说，令a是一个文法符号（终结符号或非终结符号）串。我们将FIRST(a)定义为可以
由a生成的一个或多个终结符号串的第一个符号的集合。


2.5 简单表达式的翻译器
抽象语法和具体语法：
  设计一个翻译器时，名为抽象语法树(abs)的数据结构是一个很好的起点。在一个表达式的抽象语法树中，每个内部节点代表一个运算符，该节点的子节点代表这个运算
符的运算分量。对于更加一般化的情况，当我们处理任意的程序设计语言构造时，我们可以创建一个针对这个构造的运算符，并把这个构造的具体语义信息的组成部分作为
这个运算符的运算分量。
  抽象语法树也简称为语法树，在某种程度上和语法分析树相似。但是在抽象语法树中，内部节点代表的是程序构造；而在语法分析树中，内部节点代表的是非终结符号。
文法中的很多非终结符号都代表程序的构造，但也有一部分是各种各样的辅助符号，比如那些代表项、因子或其他表达式变体的非终结符号。在抽象语法树中，通常不需要
这些辅助符号，因此会将这些符号省略掉。为了强调他们之间的区别，我们有时把语法分析树称为具体语法树，而对应的文法称为该语言的具体语法。


2.6 词法分析
  一个词法分析器从输入中读取字符，将他们组成“词法单元对象”。除了用于语法分析的终结符号之外，一个词法单元对象还包含一些附加信息，这些信息以属性值的形式
出现。
  构成一个词法单元的输入字符序列称为词素。因此，我们可以说，词法分析器使得语法分析器不需要考虑词法单元的词素表示方式。
  
（1）剔除空白和注释
  伪代码如下：
  for (;; peek = next input character) {
      if (peek is a blank or a tab) do nothing;
      else if (peek is a newline) line = line + 1;
      else break;
  }
解释：这个伪代码在遇到空格、制表符或换行符时不断读取输入字符，从而跳过了空白部分。变量peek存放了下一个输入字符。在错误消息中加入行号和上下文有助于定位
错误。这个代码使用变量line统计输入中的换行符个数。
（2）预读
  在决定向语法分析器返回哪个词法单元之前，词法分析器可能需要预先读入一些字符。比如">"和">="，如果只读一个，可能造成错误，未能表达出">="的意思来。
  一个通用的预先读取输入的方法是使用输入缓冲区。词法分析器可以从缓冲区中读取一个字符，也可以把字符放回缓冲区。
  因为通常只需预读一个字符，所以一种简单的解决方案就是使用一个变量，比如peek,来保存下一个输入字符。在读入一个数字的数位或者一个标识符的字符时，词法
分析器会预读一个字符。例如，它在预读一个字符来区分1和10，在t后预读一个字符来区分t和true.当词法分析器返回一个词法单元时，变量peek要么保存了当前词法
单元的词素后面的那个字符，要么保存空白符。
（3）常量
  在一个表达式的文法中，任何允许出现数位的地方都应该允许出现任意的整型常量。要使得表达式中可以出现整数常量，我们可以创建一个代表整形常量的终结符号，
比如num，也可以将整数常量的语法加入到文法中。将字符组成整数并计算它的数值的工作通常是由词法分析器完成的，因此在词法分析和翻译过程中可以将数组作为一个
单元进行处理。
  当在输入流中出现一个数位序列时，词法分析器将向语法分析器传送一个词法单元。该词法单元包含终结符号num及根据这些数位计算得到的整型属性值。如果我们把
词法单元写成用<>括起来的元祖，那么输入31+28+59就被转化成序列<num, 31><+><num, 28><+><num, 59>,在这里，终结符号+没有属性，所以它的元祖就是<+>。
  伪代码如下：
  if (peek holds a digit) {
      v = 0;
      do {
          v = v * 10 + integer value of digit peek;
          peek = next input character;
      }while(peek holds a digit);
      return token<num, v>;
  }
  解释：这个伪代码读取一个整数中的数位，并用变量v累计得到这个整数的值。
（4）识别关键字和标识符
  为了简化语法分析器，语言的文法通常把标识符作为终结符号来进行处理。当某个标识符出现在输入中时，语法分析器都会得到相同的终结符号，如id。例如，在处理
如下输入时：count = count + increment;语法分析器处理的是终结符号序列id = id + id.词法单元id有一个属性保存它的词素。将词法单元写作元祖形式，是如下
形式：<id, "count"><=><id, "count"><+><id, "increment"><;>。
  关键字通常也满足标识符的组成规则，因此我们需要某种机制来确定一个词素什么时候组成一个关键字，什么时候组成一个标识符。可以将关键字作为保留字，就是说
这些不能作为标识符，因此，只有当一个字符串不是关键字时，他才能组成一个标识符。

词法分析器可以使用一个表来保存字符串：
（1）单一表示：一个字符串表可以将编译器的其余部分和表中字符串的具体表示隔离开，因为编译器后面的步骤可以只使用指向表中字符串的指针和引用。操作引用要比
操作字符串本身更加高效。
（2）保留字：要实现保留字，可以在初始化时在字符串表中加入保留的字符串以及它们对应的词法单元。当词法分析器读到一个可以组成标识符的字符串或者词素时，
首先检查这个字符串表中是否有这个词素。如是，就返回表中的词法单元，否则返回带有终结符号id的词法单元。
  伪代码如下：
  if (peek存放了一个字母) {
      将字母或数位读入一个缓冲区b;
      s = b中的字符形成的字符串;
      w = words.get(s)返回的词法单元;
      if (w不是null) return w;
      else {
          将键-值对(s, <id, s>)加入到words;
          return 词法单元<id, s>;
      }
  }
  解释：words是一个散列表。Hashtable words = new Hashtable();这个伪代码从输入中读取一个以字母开头，由字母和数字组成的字符串s。我们假定读取的s尽可
能地长，即只要词法分析器遇到字母或者数位，他就不断从输入中读取字符。当它遇到的不是字母或者数位，比方说遇到了空白符，已读取的词素就被复制到缓冲区b中。
如果字符串表中已经有了一个s的条目，他就返回由words.get得到的词法单元。这里s可能是一个关键字，在表words初始化的时候这个s就已经在表中了；它也可能是一个
之前被加入到表中的标识符。如果不存在s对应的条目，那么由id和属性值s组成的词法单元将被加入到字符串表中，并被返回。


2.7 符号表
  符号表是一种供编译器用于保存有关源程序构造的各种信息的数据结构。这些信息在编译器的分析阶段被逐步收集放入符号表，它们在综合阶段用于生成目标代码。符号
表的每个条目中包含于一个标识符相关的信息，比如它的字符串（或者词素）、它的类型、它的存储位置和其他相关信息。符号表通常需要支持同一标识符在一个程序中的
多重声明。
  一个声明的作用域是指该声明起作用的那一部分程序。我们将为每个作用域建立一个单独的符号表来实现作用域。每个带有声明的程序块（程序块：在C语言中，程序块
要么是一个函数，要么是函数中由花括号分隔的一个部分，这个部分中有一个或多个声明）都会有自己的符号表，这个块中的每个声明都在此符号表中有一个对应的条目。

符号表条目：
  符号表条目是在分析阶段由词法分析器、语法分析器和语义分析器创建并使用的。在本章中，我们让语法分析器来创建这些条目。因为语法分析器知道一个程序的语法
结构，因此相对于词法分析器而言，语法分析器通常更适合创建条目。它可以更好地区分一个标识符的不同声明。

块的符号表：
  块的符号表的实现可以利用作用域的最近嵌套规则。嵌套的结构确保可应用的符号表形成一个栈。在栈的顶部是当前块的符号表。栈中这个表的下方是包含这个块的各个
块的符号表。因此，符号表可以按照类似于栈的方式来分配和释放。


2.8 生成中间代码
  编译器的前端构造出源程序的中间表示，而后端根据这个中间表示生成目标程序。本节中，主要考虑表达式和语句的中间表示。除了创建一个中间表示之外，编译器前端
还会检查源程序是否遵循源语言的语法和语义规则。这种检查称为静态检查，“静态”一般是指“由编译器完成”。静态检查确保一些特定类型的程序错误，包括类型不匹配，
能在编译过程中被检测并报告。
  
两种中间表示形式：
1.树型结构，包括语法分析树和抽象语法树
2.线性表示形式，特别是“三地址代码”

抽象语法树：
  在分析的过程中，将创建抽象语法分析树的结点来表示有意义的程序构造。随着分析的进行，信息以与结点相关的属性的形式被添加到这些结点上。选择哪些属性要依据
待完成的翻译来决定。

三地址代码：
  三地址代码是一个由基本程序步骤（比如将两个值的相加）组成的序列。和树形结构不一样，它没有层次化的结构。如果我们相对代码做出显著的优化，就需要这种表示
形式。在那种情况下，我们可以把组成程序的很长的三地址语句序列分解为“基本块”。所谓基本块就是一个总是逐个顺序执行的语句序列，执行时不会出现分支跳转。

静态检查：除了创建一个中间表示之外，编译器前端还会检查源程序是否遵循语言的语法和语义规则。这种检查称为“静态检查”。“静态”一般是指“由编译器完成”。静态
检查确保一些特定类型的程序错误，包括类型不匹配，能在编译过程中被检测并报告。


总结：
1.构造一个语法制导翻译器要从源语言的文法开始。一个文法描述了程序的层次结构。文法的定义使用了称为终结符号的基本符号和称为非终结符号的变量符号。这些符号
代表了语言的构造。一个文法的规则，即产生式，由一个作为产生式头或者产生式左部的非终结符，以及称为产生式体或产生式右部的终结符号/非终结符号序列组成。文
法中有一个非终结符被指派为开始符号。
2.在描述一个翻译器时，在程序构造中附加属性是非常有用的。属性是指与一个程序构造关联的任何量值。因为程序构造是使用文法符号来表示的，因此属性的概念也被
扩展到文法符号上。属性的例子包括与一个表示数字的终结符号num相关联的整数值，或与一个表示终结符号id相关联的字符串。
3.词法分析器从输入中逐个读取字符，并输出一个词法单元的流，其中词法单元由一个终结符号以及以属性值形式出现的附加信息组成。
4.语法分析要解决的问题是指出如何从一个文法的开始符号推导出一个给定的终结符号串。推导的方法是反复将某个非终结符替换为它的某个产生式的体。从概念上将，语
法分析树会创建一棵语法树。该树的根节点的标号为文法的开始符号，每个非叶子结点对应于一个产生式，每个叶子结点的标号为一个终结符号或者空串。语法分析树推导
出由它的叶子结点从左到右组成的终结符号串。
5.使用被称为预测语法分析树的自顶向下（从语法分析树的根节点到叶子节点）方法可以手工建立高效的语法分析器。预测分析器有对应于每个非终结符的子过程。该过程
的过程体模拟了这个非终结符的各个产生式。只要在输入流中向前看一个符号，就可以无二义地确定该过程体的控制流。
6.语法指导翻译通过在文法中添加规则或者程序片段来完成。本章中，我们只考虑了综合属性。任意节点x上的一个综合属性的值只取决于x的子节点（如果有的话）上的属
性值。语法指导定义将规则和产生式相关联，这些规则用于计算属性值。语法制导的翻译方案在产生式体中嵌入了称为语义动作的程序片段。这些语义动作按照语法分析中
产生的使用顺序执行。
7.语法分析的结果是源代码的一种中间表示形式，称为中间代码。抽象语法树中的各个结点代表了程序构造，一个结点的子结点给出了该构造有意义的子构造。另一种表示
方法是三地址代码，它是一个由三地址指令组成的序列，其中每个指令只执行一个运算。
8.符号表是存放有关标识符的信息的数据结构。当分析一个标识符的声明的时候，该标识符的信息被放入符号表中。当在后来使用这个标识符时，比如它作为一个表达式的
因子使用时，语义动作将从符号表中获取这些信息。
